name: Generate Development Roadmap Issues

on:
  workflow_dispatch:
    inputs:
      force_recreate:
        description: 'Force recreate all issues (will close existing ones)'
        required: false
        default: 'false'
        type: boolean
      roadmap_section:
        description: 'Specific roadmap section to process (leave empty for all)'
        required: false
        default: ''
        type: string
  schedule:
    # Run weekly on Mondays at 10 AM UTC to check for new roadmap tasks
    - cron: '0 10 * * 1'
  push:
    branches:
      - main
    paths:
      - 'DEVELOPMENT-ROADMAP.md'

env:
  ROADMAP_FILE: 'DEVELOPMENT-ROADMAP.md'

jobs:
  verify-roadmap:
    name: Verify Roadmap is Up-to-Date
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Verify roadmap file exists
      run: |
        if [ ! -f "${{ env.ROADMAP_FILE }}" ]; then
          echo "❌ DEVELOPMENT-ROADMAP.md not found!"
          exit 1
        fi
        echo "✅ DEVELOPMENT-ROADMAP.md found"

    - name: Check roadmap structure
      run: |
        # Verify essential sections exist
        if ! grep -q "## Next Steps" "${{ env.ROADMAP_FILE }}"; then
          echo "❌ 'Next Steps' section not found in roadmap"
          exit 1
        fi
        
        if ! grep -q "### Immediate Actions" "${{ env.ROADMAP_FILE }}"; then
          echo "❌ 'Immediate Actions' section not found in roadmap"
          exit 1
        fi
        
        echo "✅ Roadmap structure verified"

    - name: Check roadmap freshness
      id: freshness
      run: |
        # Check when the roadmap was last updated
        LAST_MODIFIED=$(git log -1 --format="%at" -- "${{ env.ROADMAP_FILE }}")
        CURRENT_TIME=$(date +%s)
        DAYS_OLD=$(( (CURRENT_TIME - LAST_MODIFIED) / 86400 ))
        
        echo "days_old=$DAYS_OLD" >> $GITHUB_OUTPUT
        echo "last_modified=$(date -d @$LAST_MODIFIED '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
        
        if [ $DAYS_OLD -gt 30 ]; then
          echo "⚠️ Roadmap is $DAYS_OLD days old (last updated: $(date -d @$LAST_MODIFIED '+%Y-%m-%d'))"
          echo "Consider reviewing and updating the roadmap"
        else
          echo "✅ Roadmap is current ($DAYS_OLD days old)"
        fi

    outputs:
      roadmap_age: ${{ steps.freshness.outputs.days_old }}
      last_updated: ${{ steps.freshness.outputs.last_modified }}

  generate-issues:
    name: Generate Issues from Roadmap
    needs: verify-roadmap
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Parse roadmap and create issues
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the roadmap file
          const roadmapContent = fs.readFileSync(process.env.ROADMAP_FILE, 'utf8');
          
          // Parse the roadmap sections with actionable items
          const parseActionableItems = (content) => {
            const sections = [];
            
            // Find "Next Steps" section
            const nextStepsMatch = content.match(/## Next Steps\n\n([\s\S]*?)(?=\n## |$)/);
            if (!nextStepsMatch) {
              console.log('No "Next Steps" section found');
              return sections;
            }
            
            const nextStepsContent = nextStepsMatch[1];
            
            // Parse subsections like "Immediate Actions", "Phase 2 Implementation", etc.
            const subsectionRegex = /### ([^#\n]+)\n\n([\s\S]*?)(?=\n### |\n## |$)/g;
            let subsectionMatch;
            
            while ((subsectionMatch = subsectionRegex.exec(nextStepsContent)) !== null) {
              const [, sectionTitle, sectionContent] = subsectionMatch;
              
              // Skip sections that don't contain actionable items
              if (sectionTitle.includes('Summary') || sectionTitle.includes('Resources') || 
                  sectionTitle.includes('Metrics') || sectionTitle.includes('Workflow')) {
                continue;
              }
              
              // Parse numbered items with tasks
              const itemRegex = /(\d+)\.\s\*\*([^*]+)\*\*[^\n]*\n((?:\s*-\s[^\n]*\n?)*)/g;
              let itemMatch;
              
              while ((itemMatch = itemRegex.exec(sectionContent)) !== null) {
                const [, itemNumber, itemTitle, tasksText] = itemMatch;
                const tasks = [];
                
                // Parse individual tasks with checkboxes
                const taskRegex = /\s*-\s\[([^\]]*)\]\s(.+)/g;
                let taskMatch;
                while ((taskMatch = taskRegex.exec(tasksText)) !== null) {
                  const [, status, description] = taskMatch;
                  tasks.push({
                    completed: status.trim() === 'x',
                    description: description.trim()
                  });
                }
                
                if (tasks.length > 0) {
                  sections.push({
                    section: sectionTitle.trim(),
                    itemNumber: parseInt(itemNumber),
                    itemTitle: itemTitle.trim(),
                    tasks: tasks
                  });
                }
              }
            }
            
            return sections;
          };
          
          // Parse Success Metrics section for additional trackable items
          const parseSuccessMetrics = (content) => {
            const metricsMatch = content.match(/### Success Metrics\n\n([\s\S]*?)(?=\n### |\n## |$)/);
            if (!metricsMatch) return [];
            
            const metricsContent = metricsMatch[1];
            const items = [];
            
            // Parse bullet points with checkboxes
            const metricRegex = /-\s\[([^\]]*)\]\s(.+)/g;
            let match;
            while ((match = metricRegex.exec(metricsContent)) !== null) {
              const [, status, description] = match;
              if (status.trim() !== 'x') {
                items.push({
                  section: 'Success Metrics',
                  itemNumber: 0,
                  itemTitle: 'Success Metrics',
                  tasks: [{
                    completed: false,
                    description: description.trim()
                  }]
                });
              }
            }
            
            return items;
          };
          
          const actionableItems = parseActionableItems(roadmapContent);
          const metricsItems = parseSuccessMetrics(roadmapContent);
          const allItems = [...actionableItems, ...metricsItems];
          
          console.log(`Found ${allItems.length} items with actionable tasks`);
          
          // Filter by section if specified
          const targetSection = context.payload.inputs?.roadmap_section || '';
          const filteredItems = targetSection ? 
            allItems.filter(item => item.section.toLowerCase().includes(targetSection.toLowerCase())) : 
            allItems;
          
          console.log(`Processing ${filteredItems.length} items${targetSection ? ` (filtered by: ${targetSection})` : ''}`);
          
          // Get existing issues to avoid duplicates
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'roadmap',
            state: 'all',
            per_page: 100
          });
          
          const existingTitles = new Set(existingIssues.data.map(issue => issue.title));
          
          // Force recreate option
          const forceRecreate = context.payload.inputs?.force_recreate === 'true';
          if (forceRecreate) {
            console.log('Force recreate enabled - closing existing roadmap issues');
            for (const issue of existingIssues.data) {
              if (issue.state === 'open' && issue.labels.some(label => label.name === 'roadmap')) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
            }
            existingTitles.clear();
          }
          
          // Create issues for incomplete tasks
          let createdCount = 0;
          let skippedCount = 0;
          
          for (const item of filteredItems) {
            const sectionLabel = item.section.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-|-$/g, '');
            
            for (const task of item.tasks) {
              if (!task.completed) {
                const issueTitle = `[${item.section}] ${task.description}`;
                
                if (!existingTitles.has(issueTitle)) {
                  // Determine priority based on section
                  const getPriority = (section) => {
                    if (section.includes('Immediate')) return 'high';
                    if (section.includes('Phase 2')) return 'medium';
                    if (section.includes('Phase 3')) return 'medium';
                    if (section.includes('Metrics')) return 'low';
                    return 'medium';
                  };
                  
                  // Determine component tags based on task description
                  const getComponentTags = (description) => {
                    const tags = [];
                    const desc = description.toLowerCase();
                    if (desc.includes('cogutil')) tags.push('cogutil');
                    if (desc.includes('atomspace')) tags.push('atomspace');
                    if (desc.includes('opencog')) tags.push('opencog');
                    if (desc.includes('pln')) tags.push('pln');
                    if (desc.includes('ure')) tags.push('ure');
                    if (desc.includes('cogserver')) tags.push('cogserver');
                    if (desc.includes('moses')) tags.push('moses');
                    if (desc.includes('test')) tags.push('testing');
                    if (desc.includes('ci') || desc.includes('pipeline')) tags.push('ci-cd');
                    if (desc.includes('doc')) tags.push('documentation');
                    return tags;
                  };
                  
                  const priority = getPriority(item.section);
                  const componentTags = getComponentTags(task.description);
                  
                  const issueBody = [
                    `## Development Roadmap Task: ${item.section}`,
                    '',
                    'This task is part of the OpenCog to Crystal conversion development roadmap.',
                    '',
                    '### Task Description',
                    task.description,
                    '',
                    '### Context',
                    `- **Section**: ${item.section}`,
                    `- **Item**: ${item.itemTitle}`,
                    `- **Priority**: ${priority}`,
                    componentTags.length > 0 ? `- **Components**: ${componentTags.join(', ')}` : '',
                    '',
                    '### Reference',
                    `This task comes from the [Development Roadmap](${context.payload.repository.html_url}/blob/main/${process.env.ROADMAP_FILE}#next-steps).`,
                    '',
                    '### Acceptance Criteria',
                    '- [ ] Task implementation completed according to roadmap specifications',
                    '- [ ] Code follows Crystal best practices and project conventions',
                    '- [ ] Appropriate tests added or updated',
                    '- [ ] Documentation updated if required',
                    '- [ ] Performance impact assessed if applicable',
                    '- [ ] Update roadmap checkbox when complete: `- [x]`',
                    '',
                    '### Definition of Done',
                    '1. Implementation meets the task requirements',
                    '2. All tests pass (existing and new)',
                    '3. Code review completed',
                    '4. Documentation is up to date',
                    '5. Roadmap is updated to mark task as complete',
                    '',
                    '---',
                    '*This issue was automatically generated from the development roadmap. ' +
                    `Last roadmap update: ${needs['verify-roadmap'].outputs.last_updated}*`
                  ].filter(line => line !== '').join('\n');

                  try {
                    const labels = [
                      'roadmap', 
                      'crystal-conversion', 
                      sectionLabel, 
                      `priority-${priority}`,
                      ...componentTags
                    ].filter((label, index, arr) => arr.indexOf(label) === index); // Remove duplicates

                    const issue = await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: issueTitle,
                      body: issueBody,
                      labels: labels
                    });
                    
                    console.log(`✅ Created issue: ${issueTitle}`);
                    createdCount++;
                  } catch (error) {
                    console.error(`❌ Failed to create issue "${issueTitle}": ${error.message}`);
                  }
                } else {
                  console.log(`⏭️ Issue already exists: ${issueTitle}`);
                  skippedCount++;
                }
              }
            }
          }
          
          // Log summary
          console.log(`\n📊 Summary:`);
          console.log(`- Found ${filteredItems.length} roadmap items to process`);
          console.log(`- Created ${createdCount} new issues`);
          console.log(`- Skipped ${skippedCount} existing issues`);
          console.log(`- Roadmap age: ${needs['verify-roadmap'].outputs.roadmap_age} days`);
          
          // Create summary comment if running manually
          if (context.eventName === 'workflow_dispatch') {
            const summary = [
              '## Development Roadmap Issues Generation Summary',
              '',
              '### Processing Results',
              `- **Roadmap processed**: \`${process.env.ROADMAP_FILE}\``,
              `- **Last updated**: ${needs['verify-roadmap'].outputs.last_updated}`,
              `- **Age**: ${needs['verify-roadmap'].outputs.roadmap_age} days old`,
              `- **Section filter**: ${targetSection || 'All sections'}`,
              `- **Force recreate**: ${forceRecreate ? 'Yes' : 'No'}`,
              '',
              '### Issues Generated',
              `- ✅ **Created**: ${createdCount} new issues`,
              `- ⏭️ **Skipped**: ${skippedCount} existing issues`,
              `- 📋 **Items processed**: ${filteredItems.length}`,
              '',
              '### Labels Applied',
              '- `roadmap` - All roadmap-generated issues',
              '- `crystal-conversion` - Part of Crystal conversion project',
              '- `priority-{high,medium,low}` - Based on roadmap section',
              '- Component-specific labels (e.g., `cogutil`, `atomspace`)',
              '- Section-specific labels (e.g., `immediate-actions`)',
              '',
              '### Next Steps',
              '1. Review and assign the newly created issues',
              '2. Update roadmap checkboxes as tasks are completed',
              '3. Roadmap will be re-processed weekly or when updated',
              '',
              '---',
              `**View all roadmap issues**: [Issues with roadmap label](${context.payload.repository.html_url}/issues?q=is%3Aissue+label%3Aroadmap)`
            ].join('\n');

            // Look for existing summary issue
            const summaryIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'roadmap-tracking',
              state: 'open'
            });
            
            if (summaryIssues.data.length > 0) {
              // Update existing summary issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: summaryIssues.data[0].number,
                body: summary
              });
            } else {
              // Create new summary issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Development Roadmap Issues Tracking',
                body: [
                  'This issue tracks the automatic generation of issues from the development roadmap.',
                  '',
                  summary
                ].join('\n'),
                labels: ['roadmap-tracking', 'tracking']
              });
            }
          }
          
          // Set outputs for downstream jobs
          core.setOutput('created_count', createdCount);
          core.setOutput('skipped_count', skippedCount);
          core.setOutput('total_items', filteredItems.length);

    outputs:
      created_count: ${{ steps.generate-issues.outputs.created_count }}
      skipped_count: ${{ steps.generate-issues.outputs.skipped_count }}
      total_items: ${{ steps.generate-issues.outputs.total_items }}

  notify-completion:
    name: Notify Completion
    needs: [verify-roadmap, generate-issues]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Summary notification
      run: |
        echo "🎯 Development Roadmap Issues Generation Complete"
        echo ""
        echo "📊 Results:"
        echo "  - Roadmap age: ${{ needs.verify-roadmap.outputs.roadmap_age }} days"
        echo "  - Created issues: ${{ needs.generate-issues.outputs.created_count || 0 }}"
        echo "  - Skipped existing: ${{ needs.generate-issues.outputs.skipped_count || 0 }}"
        echo "  - Total items processed: ${{ needs.generate-issues.outputs.total_items || 0 }}"
        echo ""
        echo "✅ Workflow completed successfully!"